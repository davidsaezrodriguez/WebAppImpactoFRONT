import { OnInit, ElementRef, Renderer2, EventEmitter, OnDestroy, OnChanges, NgZone, SimpleChanges, TemplateRef, ViewContainerRef } from '@angular/core';
import { Subject, ReplaySubject } from 'rxjs';
import { DraggableHelper } from './draggable-helper.provider';
import { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';
import * as ɵngcc0 from '@angular/core';
export interface Coordinates {
    x: number;
    y: number;
}
export interface DragAxis {
    x: boolean;
    y: boolean;
}
export interface SnapGrid {
    x?: number;
    y?: number;
}
export interface DragPointerDownEvent extends Coordinates {
}
export interface DragStartEvent {
    cancelDrag$: ReplaySubject<void>;
}
export interface DragMoveEvent extends Coordinates {
}
export interface DragEndEvent extends Coordinates {
    dragCancelled: boolean;
}
export interface ValidateDragParams extends Coordinates {
    transform: {
        x: number;
        y: number;
    };
}
export declare type ValidateDrag = (params: ValidateDragParams) => boolean;
export interface PointerEvent {
    clientX: number;
    clientY: number;
    event: MouseEvent | TouchEvent;
}
export interface TimeLongPress {
    timerBegin: number;
    timerEnd: number;
}
export interface GhostElementCreatedEvent {
    clientX: number;
    clientY: number;
    element: HTMLElement;
}
export declare class DraggableDirective implements OnInit, OnChanges, OnDestroy {
    private element;
    private renderer;
    private draggableHelper;
    private zone;
    private vcr;
    private scrollContainer;
    private document;
    /**
     * an object of data you can pass to the drop event
     */
    dropData: any;
    /**
     * The axis along which the element is draggable
     */
    dragAxis: DragAxis;
    /**
     * Snap all drags to an x / y grid
     */
    dragSnapGrid: SnapGrid;
    /**
     * Show a ghost element that shows the drag when dragging
     */
    ghostDragEnabled: boolean;
    /**
     * Show the original element when ghostDragEnabled is true
     */
    showOriginalElementWhileDragging: boolean;
    /**
     * Allow custom behaviour to control when the element is dragged
     */
    validateDrag: ValidateDrag;
    /**
     * The cursor to use when hovering over a draggable element
     */
    dragCursor: string;
    /**
     * The css class to apply when the element is being dragged
     */
    dragActiveClass: string;
    /**
     * The element the ghost element will be appended to. Default is next to the dragged element
     */
    ghostElementAppendTo: HTMLElement;
    /**
     * An ng-template to be inserted into the parent element of the ghost element. It will overwrite any child nodes.
     */
    ghostElementTemplate: TemplateRef<any>;
    /**
     * Amount of milliseconds to wait on touch devices before starting to drag the element (so that you can scroll the page by touching a draggable element)
     */
    touchStartLongPress: {
        delay: number;
        delta: number;
    };
    /**
     * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it
     */
    dragPointerDown: EventEmitter<DragPointerDownEvent>;
    /**
     * Called when the element has started to be dragged.
     * Only called after at least one mouse or touch move event.
     * If you call $event.cancelDrag$.emit() it will cancel the current drag
     */
    dragStart: EventEmitter<DragStartEvent>;
    /**
     * Called after the ghost element has been created
     */
    ghostElementCreated: EventEmitter<GhostElementCreatedEvent>;
    /**
     * Called when the element is being dragged
     */
    dragging: EventEmitter<DragMoveEvent>;
    /**
     * Called after the element is dragged
     */
    dragEnd: EventEmitter<DragEndEvent>;
    /**
     * @hidden
     */
    pointerDown$: Subject<PointerEvent>;
    /**
     * @hidden
     */
    pointerMove$: Subject<PointerEvent>;
    /**
     * @hidden
     */
    pointerUp$: Subject<PointerEvent>;
    private eventListenerSubscriptions;
    private ghostElement;
    private destroy$;
    private timeLongPress;
    private scroller;
    /**
     * @hidden
     */
    constructor(element: ElementRef<HTMLElement>, renderer: Renderer2, draggableHelper: DraggableHelper, zone: NgZone, vcr: ViewContainerRef, scrollContainer: DraggableScrollContainerDirective, document: any);
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    private checkEventListeners;
    private onMouseDown;
    private onMouseUp;
    private onTouchStart;
    private onTouchEnd;
    private onMouseEnter;
    private onMouseLeave;
    private canDrag;
    private setCursor;
    private unsubscribeEventListeners;
    private setElementStyles;
    private getScrollElement;
    private getScrollPosition;
    private shouldBeginDrag;
    private enableScroll;
    private disableScroll;
    private hasScrollbar;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DraggableDirective, [null, null, null, null, null, { optional: true; }, null]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<DraggableDirective, "[mwlDraggable]", never, { "dragAxis": "dragAxis"; "dragSnapGrid": "dragSnapGrid"; "ghostDragEnabled": "ghostDragEnabled"; "showOriginalElementWhileDragging": "showOriginalElementWhileDragging"; "dragCursor": "dragCursor"; "dropData": "dropData"; "validateDrag": "validateDrag"; "dragActiveClass": "dragActiveClass"; "ghostElementAppendTo": "ghostElementAppendTo"; "ghostElementTemplate": "ghostElementTemplate"; "touchStartLongPress": "touchStartLongPress"; }, { "dragPointerDown": "dragPointerDown"; "dragStart": "dragStart"; "ghostElementCreated": "ghostElementCreated"; "dragging": "dragging"; "dragEnd": "dragEnd"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZ2dhYmxlLmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJkcmFnZ2FibGUuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPbkluaXQsIEVsZW1lbnRSZWYsIFJlbmRlcmVyMiwgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIE9uQ2hhbmdlcywgTmdab25lLCBTaW1wbGVDaGFuZ2VzLCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCwgUmVwbGF5U3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgRHJhZ2dhYmxlSGVscGVyIH0gZnJvbSAnLi9kcmFnZ2FibGUtaGVscGVyLnByb3ZpZGVyJztcbmltcG9ydCB7IERyYWdnYWJsZVNjcm9sbENvbnRhaW5lckRpcmVjdGl2ZSB9IGZyb20gJy4vZHJhZ2dhYmxlLXNjcm9sbC1jb250YWluZXIuZGlyZWN0aXZlJztcbmV4cG9ydCBpbnRlcmZhY2UgQ29vcmRpbmF0ZXMge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG59XG5leHBvcnQgaW50ZXJmYWNlIERyYWdBeGlzIHtcbiAgICB4OiBib29sZWFuO1xuICAgIHk6IGJvb2xlYW47XG59XG5leHBvcnQgaW50ZXJmYWNlIFNuYXBHcmlkIHtcbiAgICB4PzogbnVtYmVyO1xuICAgIHk/OiBudW1iZXI7XG59XG5leHBvcnQgaW50ZXJmYWNlIERyYWdQb2ludGVyRG93bkV2ZW50IGV4dGVuZHMgQ29vcmRpbmF0ZXMge1xufVxuZXhwb3J0IGludGVyZmFjZSBEcmFnU3RhcnRFdmVudCB7XG4gICAgY2FuY2VsRHJhZyQ6IFJlcGxheVN1YmplY3Q8dm9pZD47XG59XG5leHBvcnQgaW50ZXJmYWNlIERyYWdNb3ZlRXZlbnQgZXh0ZW5kcyBDb29yZGluYXRlcyB7XG59XG5leHBvcnQgaW50ZXJmYWNlIERyYWdFbmRFdmVudCBleHRlbmRzIENvb3JkaW5hdGVzIHtcbiAgICBkcmFnQ2FuY2VsbGVkOiBib29sZWFuO1xufVxuZXhwb3J0IGludGVyZmFjZSBWYWxpZGF0ZURyYWdQYXJhbXMgZXh0ZW5kcyBDb29yZGluYXRlcyB7XG4gICAgdHJhbnNmb3JtOiB7XG4gICAgICAgIHg6IG51bWJlcjtcbiAgICAgICAgeTogbnVtYmVyO1xuICAgIH07XG59XG5leHBvcnQgZGVjbGFyZSB0eXBlIFZhbGlkYXRlRHJhZyA9IChwYXJhbXM6IFZhbGlkYXRlRHJhZ1BhcmFtcykgPT4gYm9vbGVhbjtcbmV4cG9ydCBpbnRlcmZhY2UgUG9pbnRlckV2ZW50IHtcbiAgICBjbGllbnRYOiBudW1iZXI7XG4gICAgY2xpZW50WTogbnVtYmVyO1xuICAgIGV2ZW50OiBNb3VzZUV2ZW50IHwgVG91Y2hFdmVudDtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVGltZUxvbmdQcmVzcyB7XG4gICAgdGltZXJCZWdpbjogbnVtYmVyO1xuICAgIHRpbWVyRW5kOiBudW1iZXI7XG59XG5leHBvcnQgaW50ZXJmYWNlIEdob3N0RWxlbWVudENyZWF0ZWRFdmVudCB7XG4gICAgY2xpZW50WDogbnVtYmVyO1xuICAgIGNsaWVudFk6IG51bWJlcjtcbiAgICBlbGVtZW50OiBIVE1MRWxlbWVudDtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIERyYWdnYWJsZURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgZWxlbWVudDtcbiAgICBwcml2YXRlIHJlbmRlcmVyO1xuICAgIHByaXZhdGUgZHJhZ2dhYmxlSGVscGVyO1xuICAgIHByaXZhdGUgem9uZTtcbiAgICBwcml2YXRlIHZjcjtcbiAgICBwcml2YXRlIHNjcm9sbENvbnRhaW5lcjtcbiAgICBwcml2YXRlIGRvY3VtZW50O1xuICAgIC8qKlxuICAgICAqIGFuIG9iamVjdCBvZiBkYXRhIHlvdSBjYW4gcGFzcyB0byB0aGUgZHJvcCBldmVudFxuICAgICAqL1xuICAgIGRyb3BEYXRhOiBhbnk7XG4gICAgLyoqXG4gICAgICogVGhlIGF4aXMgYWxvbmcgd2hpY2ggdGhlIGVsZW1lbnQgaXMgZHJhZ2dhYmxlXG4gICAgICovXG4gICAgZHJhZ0F4aXM6IERyYWdBeGlzO1xuICAgIC8qKlxuICAgICAqIFNuYXAgYWxsIGRyYWdzIHRvIGFuIHggLyB5IGdyaWRcbiAgICAgKi9cbiAgICBkcmFnU25hcEdyaWQ6IFNuYXBHcmlkO1xuICAgIC8qKlxuICAgICAqIFNob3cgYSBnaG9zdCBlbGVtZW50IHRoYXQgc2hvd3MgdGhlIGRyYWcgd2hlbiBkcmFnZ2luZ1xuICAgICAqL1xuICAgIGdob3N0RHJhZ0VuYWJsZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2hvdyB0aGUgb3JpZ2luYWwgZWxlbWVudCB3aGVuIGdob3N0RHJhZ0VuYWJsZWQgaXMgdHJ1ZVxuICAgICAqL1xuICAgIHNob3dPcmlnaW5hbEVsZW1lbnRXaGlsZURyYWdnaW5nOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEFsbG93IGN1c3RvbSBiZWhhdmlvdXIgdG8gY29udHJvbCB3aGVuIHRoZSBlbGVtZW50IGlzIGRyYWdnZWRcbiAgICAgKi9cbiAgICB2YWxpZGF0ZURyYWc6IFZhbGlkYXRlRHJhZztcbiAgICAvKipcbiAgICAgKiBUaGUgY3Vyc29yIHRvIHVzZSB3aGVuIGhvdmVyaW5nIG92ZXIgYSBkcmFnZ2FibGUgZWxlbWVudFxuICAgICAqL1xuICAgIGRyYWdDdXJzb3I6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgY3NzIGNsYXNzIHRvIGFwcGx5IHdoZW4gdGhlIGVsZW1lbnQgaXMgYmVpbmcgZHJhZ2dlZFxuICAgICAqL1xuICAgIGRyYWdBY3RpdmVDbGFzczogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBlbGVtZW50IHRoZSBnaG9zdCBlbGVtZW50IHdpbGwgYmUgYXBwZW5kZWQgdG8uIERlZmF1bHQgaXMgbmV4dCB0byB0aGUgZHJhZ2dlZCBlbGVtZW50XG4gICAgICovXG4gICAgZ2hvc3RFbGVtZW50QXBwZW5kVG86IEhUTUxFbGVtZW50O1xuICAgIC8qKlxuICAgICAqIEFuIG5nLXRlbXBsYXRlIHRvIGJlIGluc2VydGVkIGludG8gdGhlIHBhcmVudCBlbGVtZW50IG9mIHRoZSBnaG9zdCBlbGVtZW50LiBJdCB3aWxsIG92ZXJ3cml0ZSBhbnkgY2hpbGQgbm9kZXMuXG4gICAgICovXG4gICAgZ2hvc3RFbGVtZW50VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogQW1vdW50IG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IG9uIHRvdWNoIGRldmljZXMgYmVmb3JlIHN0YXJ0aW5nIHRvIGRyYWcgdGhlIGVsZW1lbnQgKHNvIHRoYXQgeW91IGNhbiBzY3JvbGwgdGhlIHBhZ2UgYnkgdG91Y2hpbmcgYSBkcmFnZ2FibGUgZWxlbWVudClcbiAgICAgKi9cbiAgICB0b3VjaFN0YXJ0TG9uZ1ByZXNzOiB7XG4gICAgICAgIGRlbGF5OiBudW1iZXI7XG4gICAgICAgIGRlbHRhOiBudW1iZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudCBjYW4gYmUgZHJhZ2dlZCBhbG9uZyBvbmUgYXhpcyBhbmQgaGFzIHRoZSBtb3VzZSBvciBwb2ludGVyIGRldmljZSBwcmVzc2VkIG9uIGl0XG4gICAgICovXG4gICAgZHJhZ1BvaW50ZXJEb3duOiBFdmVudEVtaXR0ZXI8RHJhZ1BvaW50ZXJEb3duRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBzdGFydGVkIHRvIGJlIGRyYWdnZWQuXG4gICAgICogT25seSBjYWxsZWQgYWZ0ZXIgYXQgbGVhc3Qgb25lIG1vdXNlIG9yIHRvdWNoIG1vdmUgZXZlbnQuXG4gICAgICogSWYgeW91IGNhbGwgJGV2ZW50LmNhbmNlbERyYWckLmVtaXQoKSBpdCB3aWxsIGNhbmNlbCB0aGUgY3VycmVudCBkcmFnXG4gICAgICovXG4gICAgZHJhZ1N0YXJ0OiBFdmVudEVtaXR0ZXI8RHJhZ1N0YXJ0RXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCBhZnRlciB0aGUgZ2hvc3QgZWxlbWVudCBoYXMgYmVlbiBjcmVhdGVkXG4gICAgICovXG4gICAgZ2hvc3RFbGVtZW50Q3JlYXRlZDogRXZlbnRFbWl0dGVyPEdob3N0RWxlbWVudENyZWF0ZWRFdmVudD47XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgYmVpbmcgZHJhZ2dlZFxuICAgICAqL1xuICAgIGRyYWdnaW5nOiBFdmVudEVtaXR0ZXI8RHJhZ01vdmVFdmVudD47XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFmdGVyIHRoZSBlbGVtZW50IGlzIGRyYWdnZWRcbiAgICAgKi9cbiAgICBkcmFnRW5kOiBFdmVudEVtaXR0ZXI8RHJhZ0VuZEV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcG9pbnRlckRvd24kOiBTdWJqZWN0PFBvaW50ZXJFdmVudD47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHBvaW50ZXJNb3ZlJDogU3ViamVjdDxQb2ludGVyRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwb2ludGVyVXAkOiBTdWJqZWN0PFBvaW50ZXJFdmVudD47XG4gICAgcHJpdmF0ZSBldmVudExpc3RlbmVyU3Vic2NyaXB0aW9ucztcbiAgICBwcml2YXRlIGdob3N0RWxlbWVudDtcbiAgICBwcml2YXRlIGRlc3Ryb3kkO1xuICAgIHByaXZhdGUgdGltZUxvbmdQcmVzcztcbiAgICBwcml2YXRlIHNjcm9sbGVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PiwgcmVuZGVyZXI6IFJlbmRlcmVyMiwgZHJhZ2dhYmxlSGVscGVyOiBEcmFnZ2FibGVIZWxwZXIsIHpvbmU6IE5nWm9uZSwgdmNyOiBWaWV3Q29udGFpbmVyUmVmLCBzY3JvbGxDb250YWluZXI6IERyYWdnYWJsZVNjcm9sbENvbnRhaW5lckRpcmVjdGl2ZSwgZG9jdW1lbnQ6IGFueSk7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIHByaXZhdGUgY2hlY2tFdmVudExpc3RlbmVycztcbiAgICBwcml2YXRlIG9uTW91c2VEb3duO1xuICAgIHByaXZhdGUgb25Nb3VzZVVwO1xuICAgIHByaXZhdGUgb25Ub3VjaFN0YXJ0O1xuICAgIHByaXZhdGUgb25Ub3VjaEVuZDtcbiAgICBwcml2YXRlIG9uTW91c2VFbnRlcjtcbiAgICBwcml2YXRlIG9uTW91c2VMZWF2ZTtcbiAgICBwcml2YXRlIGNhbkRyYWc7XG4gICAgcHJpdmF0ZSBzZXRDdXJzb3I7XG4gICAgcHJpdmF0ZSB1bnN1YnNjcmliZUV2ZW50TGlzdGVuZXJzO1xuICAgIHByaXZhdGUgc2V0RWxlbWVudFN0eWxlcztcbiAgICBwcml2YXRlIGdldFNjcm9sbEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBnZXRTY3JvbGxQb3NpdGlvbjtcbiAgICBwcml2YXRlIHNob3VsZEJlZ2luRHJhZztcbiAgICBwcml2YXRlIGVuYWJsZVNjcm9sbDtcbiAgICBwcml2YXRlIGRpc2FibGVTY3JvbGw7XG4gICAgcHJpdmF0ZSBoYXNTY3JvbGxiYXI7XG59XG4iXX0=